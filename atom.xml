<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/devwdm/devwdm.github.io</id>
    <title>Gridea</title>
    <updated>2020-06-17T06:15:31.352Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://github.com/devwdm/devwdm.github.io"/>
    <link rel="self" href="https://github.com/devwdm/devwdm.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://github.com/devwdm/devwdm.github.io/images/avatar.png</logo>
    <icon>https://github.com/devwdm/devwdm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[GoLand（狗浪） 学习笔记]]></title>
        <id>https://github.com/devwdm/devwdm.github.io/post/golandgou-lang-xue-xi-bi-ji/</id>
        <link href="https://github.com/devwdm/devwdm.github.io/post/golandgou-lang-xue-xi-bi-ji/">
        </link>
        <updated>2020-06-17T06:10:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="goland狗浪-学习笔记">GoLand（狗浪） 学习笔记</h1>
<h2 id="version">Version</h2>
<pre><code class="language-sh">$ go version
go version go1.14.2 darwin/amd64
</code></pre>
<h2 id="hello-world">Hello World</h2>
<pre><code class="language-go">//包名
package main

//导入包
import (
	&quot;fmt&quot;
)
//程序运行主函数
func main() {
	fmt.Println(&quot;Hello World&quot;)
}
</code></pre>
<p>执行命令，编译并运行程序</p>
<pre><code class="language-shell">$ go run main.go
Hello World
</code></pre>
<h2 id="test">Test</h2>
<p>测试文件(xxx_test.go)必须与测试文件在同一目录下</p>
<pre><code class="language-go">package model

import (
	&quot;fmt&quot;
	&quot;testing&quot;
)
//在测试函数执行之前先运行，可以干自己想干的事情
func TestMain(m *testing.M) {
	fmt.Println(&quot;测试开始了&quot;)
	//	通过m.run()来执行子测试函数
	m.Run()
}
//测试用户相关函数
func TestUser(t *testing.T) {
   fmt.Println(&quot;开始测试了&quot;)
   //通过t.run来执行子测试函数
   t.Run(&quot;测试用户相关的方法&quot;, testAddUser)
}

//小写test开头 那么函数不会被执行的， 我们可以将它设置为一个子测试函数
func testAddUser(t *testing.T) {
   fmt.Println(&quot;子测试函数&quot;)
   //调用的具体方法
}
</code></pre>
<p>执行测试命令</p>
<pre><code class="language-shell">$ go test
测试开始了
开始测试了
测试添加用户
PASS
ok 
//显示详细测试信息命令
$ go test -v 
</code></pre>
<h2 id="mysql">MYSQL</h2>
<h3 id="utils包">utils包</h3>
<pre><code class="language-go">package utils

import (
	&quot;database/sql&quot;
	_ &quot;github.com/go-sql-driver/mysql&quot;
	&quot;strings&quot;
)

/*
定义常量 隐
数据库配置
*/
const (
	userName = &quot;root&quot;
	password = &quot;123456&quot;
	ip       = &quot;127.0.0.1&quot;
	port     = &quot;3306&quot;
	dbName   = &quot;vip&quot;
	//设置数据库最大连接数
	connMax = 100
	//设置上数据库最大闲置连接数
	MaxIdleConns = 10
)

//Db数据库连接池
var (
	Db  *sql.DB
	err error
)

func init() {
	//构建连接：&quot;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&quot;
	path := strings.Join([]string{userName, &quot;:&quot;, password, &quot;@tcp(&quot;, ip, &quot;:&quot;, port, &quot;)/&quot;, dbName, &quot;?charset=utf8&quot;}, &quot;&quot;)
	//导入mysql 数据库驱动： _ &quot;github.com/go-sql-driver/mysql&quot;
	Db, err = sql.Open(&quot;mysql&quot;, path)
	Db.SetConnMaxLifetime(connMax)
	Db.SetMaxIdleConns(MaxIdleConns)
	//验证连接
	if err != nil {
		panic(err.Error())
	}
}
</code></pre>
<h3 id="查询">查询</h3>
<ol>
<li>
<p>判断是查询结果是否为空</p>
<pre><code class="language-go">	sqlstr := &quot;SELECT ID FROM vipInfo WHERE Name=?&quot;
	row := utils.Db.QueryRow(sqlstr, name)
	var ID int
	err := row.Scan(&amp;ID)
	if err == sql.ErrNoRows {
		return false
	} else {
		return true
	}
</code></pre>
</li>
<li>
<p>查询所有符合条件的记录</p>
<pre><code class="language-go">//GetAllAdminInfo 获取所有用户信息
func GetAllAdminInfo() ([]*model.AdminInfo, error) {
	sqlstr := &quot;SELECT id, username, sex, mobile, cretime, lastlogin FROM adminInfo WHERE isDelete=0&quot;
	rows, err := utils.Db.Query(sqlstr)
	if err != nil {
		return nil, err
	}
	var admins []*model.AdminInfo
	for rows.Next() {
		admin := &amp;model.AdminInfo{}
		rows.Scan(&amp;admin.ID, &amp;admin.Username, &amp;admin.Sex, &amp;admin.Mobile, &amp;admin.CreTime, &amp;admin.LastLogin)
		admins = append(admins, admin)
	}
	return admins, nil
}
</code></pre>
</li>
<li>
<p>分页查询</p>
<pre><code>
</code></pre>
</li>
</ol>
<h3 id="更新">更新</h3>
<pre><code class="language-go">//UpdateAdminPass 修改密码
func UpdateAdminPassword(password string, ID int) error {
	//写sql语句
	sqlStr := &quot;UPDATE adminInfo SET Password=? WHERE ID=?;&quot;
	//执行
	_, err := utils.Db.Exec(sqlStr, password, ID)
	if err != nil {
		return err
	} else {
		return nil
	}
}
</code></pre>
<h3 id="添加">添加</h3>
<pre><code class="language-go">//AddAdmin 添加用户
func AddAdmin(admin *model.AdminInfo) error {
	//写sql语句
	sqlStr := &quot;INSERT INTO adminInfo(username, password, sex, mobile) VALUE ( ?, ?, ?, ?)&quot;
	//执行
	_, err := utils.Db.Exec(sqlStr, admin.Username, admin.Password, admin.Sex, admin.Mobile)
	if err != nil {
		return err
	}
	return nil
}
</code></pre>
<h2 id="cookie">Cookie</h2>
<ol>
<li>创建</li>
</ol>
<pre><code class="language-go">import &quot;net/http&quot;

// setCookie 添加Cookie
func setCookie(w http.ResponseWriter, r *http.Request) {
	// 创建Cookie
	cookie := http.Cookie{
		Name:     &quot;user&quot;,
		Value:    &quot;admin&quot;,
		HttpOnly: true,
	}
	// 将Cookie发送给浏览器
  //方式1
	// w.Header().Set(&quot;Set-Cookie&quot;, cookie.String())
	// 添加第二个Cookie
	// w.Header().Add(&quot;Set-Cookie&quot;, cookie2.String())
	
  //方式2
  //直接调用http的SetCookie函数设置Cookie
	http.SetCookie(w, &amp;cookie)
}
</code></pre>
<ol start="2">
<li>获取</li>
</ol>
<pre><code class="language-go">// setCookie 添加Cookie
func setCookie(w http.ResponseWriter, r *http.Request) {
	// 创建Cookie
	cookie := http.Cookie{
		Name:     &quot;user&quot;,
		Value:    &quot;admin&quot;,
		HttpOnly: true,
		MaxAge:   2  0,
	}
	cookie2 := http.Cookie{
		Name:     &quot;user2&quot;,
		Value:    &quot;admin2&quot;,
		HttpOnly: true,
		MaxAge:   60,
	}
	// 将Cookie发送给浏览器
  //方式1
	// w.Header().Set(&quot;Set-Cookie&quot;, cookie.String())
	// 添加第二个Cookie
	// w.Header().Add(&quot;Set-Cookie&quot;, cookie2.String())
  //方式2
	//直接调用http的SetCookie函数设置Cookie
	http.SetCookie(w, &amp;cookie)
	http.SetCookie(w, &amp;cookie2)
}
</code></pre>
<h2 id="session">Session</h2>
<pre><code class="language-go">			//用户名和密码正确
			//生成UUID作为Session的id
			uuid := utils.CreateUUID()
			//创建一个Session
			sess := &amp;model.Session{
				SessionID: uuid,
				UserName:  admin.Username,
				AdminID:   admin.ID,
			}
			//将Session保存到数据库中
			dao.AddSession(sess)
			//创建一个Cookie，让它与Session相关联
			cookie := http.Cookie{
				Name:     &quot;user&quot;,
				Value:    uuid,
				HttpOnly: true,
			}
			//将cookie发送给浏览器
			http.SetCookie(w, &amp;cookie)
			t := template.Must(template.ParseFiles(&quot;views/pages/admin/index.html&quot;))
			t.Execute(w, &quot;true&quot;)
</code></pre>
<h2 id="ajax">Ajax</h2>
<h3 id="post">POST</h3>
<pre><code class="language-javascript">&lt;script&gt;
    $(function () {
        //发送Ajax请求验证当前密码是否正确
        $(&quot;#oldpwd&quot;).change(function () {
            // var oldpwd = $(this).val();
            var oldpwd = $(&quot;#oldpwd&quot;).val();
            //设置请求地址
            var url = &quot;/checkAdminOldPwd&quot;;
            //设置请求参数
            var param = {&quot;oldpwd&quot;: oldpwd, &quot;ID&quot;: 1};
            //发送Ajax请求
            $.post(url, param, function (res) {
              //res 后台返回值
                if(res==&quot;true&quot;) {
                    $(&quot;#msg&quot;).text(&quot;&quot;)
                } else {
                    $(&quot;#msg&quot;).text(&quot;旧密码错误&quot;)
                }
            });
        });
    });
&lt;/script&gt;
</code></pre>
<pre><code class="language-go">//controller

//CheckAdminOldPwd 验证旧密码是否正确
func CheckAdminOldPwd(w http.ResponseWriter, r *http.Request) {
	id := r.PostFormValue(&quot;ID&quot;)
	//类型转换
	idInt, _ := strconv.Atoi(id)
	oldpwd := r.PostFormValue(&quot;oldpwd&quot;)
	result := dao.CheckAdminPassword(oldpwd, idInt)
	if result {
		//当前密码正确
		w.Write([]byte(&quot;true&quot;))
	} else {
		w.Write([]byte(&quot;false&quot;))
	}
}

</code></pre>
<h2 id="数据类型转换">数据类型转换</h2>
<pre><code class="language-go">#string到int
int,err:=strconv.Atoi(string)
#string到int64
int64, err := strconv.ParseInt(string, 10, 64)
#int到string
string:=strconv.Itoa(int)
#int64到string
string:=strconv.FormatInt(int64,10)
</code></pre>
<h2 id="jquery">Jquery</h2>
<h4 id="性别转换">性别转换</h4>
<pre><code class="language-javascript">//方式1
&lt;script&gt;
	(&quot;{{.Sex}}&quot; == &quot;0&quot;) ? sex = &quot;男&quot; : sex = &quot;女&quot;;
	document.write(sex);
&lt;/script&gt;
//方式2
&lt;script&gt;
  switch ({{.Sex}}) {
    case 0:
    document.write(&quot;男&quot;);
    break;
    case 1:
    document.write(&quot;女&quot;);
    break;
    default:
    document.write(&quot;男&quot;);
  }
&lt;/script&gt;
//方式3
&lt;script&gt;
  if (&quot;{{.Sex}}&quot; == &quot;0&quot;) {
  document.write(&quot;男&quot;);
  }else{
  document.write(&quot;女&quot;);
  }
&lt;/script&gt;
</code></pre>
<h2 id="热加载调试hot-reload">热加载调试Hot Reload</h2>
<p>安装</p>
<pre><code class="language-shell">go get -v -u github.com/pilu/fresh
</code></pre>
<p>安装好后，只需要将<code>go run main.go</code>命令换成<code>fresh</code>即可。每次更改源文件，代码将自动重新编译(Auto Compile)。</p>
<h2 id="项目部署">项目部署</h2>
<h3 id="编译">编译</h3>
<ol>
<li>MAC下编译为Linux和Windows 64位可执行文件</li>
</ol>
<pre><code class="language-shell">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go
</code></pre>
<ol start="2">
<li>Linux 下编译 Mac 和 Windows 64位可执行程序</li>
</ol>
<pre><code class="language-shell">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go
</code></pre>
<ol start="3">
<li>Windows 下编译 Mac 和 Linux 64位可执行程序</li>
</ol>
<pre><code class="language-shell">SET CGO_ENABLED=0
SET GOOS=darwin
SET GOARCH=amd64
go build main.go

SET CGO_ENABLED=0
SET GOOS=linux
SET GOARCH=amd64
go build main.go
</code></pre>
<p>GOOS：目标平台的操作系统（darwin、freebsd、linux、windows）</p>
<p>GOARCH：目标平台的体系架构（386、amd64、arm）</p>
<p>交叉编译不支持 CGO 所以要禁用它</p>
<h3 id="运行">运行</h3>
<ol>
<li>Linux 后台运行</li>
</ol>
<pre><code class="language-shell">nohup ./main &amp;
</code></pre>
<h2 id="dockerfile">Dockerfile</h2>
<pre><code class="language-dockerfile"># 镜像
FROM golang
# 创建工作工作目录
WORKDIR $GOPATH/src/golang
# 复制文件到到镜像指定目录
COPY . $GOPATH/src/golang
# 构建镜像
RUN go build .
# 暴露端口
EXPOSE 8001
# 程序入入口
ENTRYPOINT [&quot;./golang&quot;]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么会有写博客这个想法]]></title>
        <id>https://github.com/devwdm/devwdm.github.io/post/xie-bo-ke-de-yuan-yin/</id>
        <link href="https://github.com/devwdm/devwdm.github.io/post/xie-bo-ke-de-yuan-yin/">
        </link>
        <updated>2020-01-06T05:54:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么会有写博客这个想法">为什么会有写博客这个想法</h1>
<h2 id="诞生">诞生</h2>
<p>我的想法很简单，通过写博客来总结我所以学习的东西。这样也方便我自己日后查看，至于其他的我没有想过。就这样子开始诞生了一个要自己搭建博客的想法，我已经不记得我具体哪个时间开始有这个想法。诞生这个想法大概是我在大三的时候，也就是一年多之前的事情。</p>
<h2 id="首个博客">首个博客</h2>
<p>我用的是Hexo这个来搭建我的第一个博客，其实事情进展得并没有那么顺利。我在本机搭建好写好博客想推送到我自己的云服务器的时候总是推送失败，后来放弃了推送到远程服务器。这个事情没有坚持多久，很快就放弃。其中一个原因是它不能推送到远程服器，其实Hexo是有这个功能及网有很多大神也写教程。但我照着做了，也没有成功就这样放弃了。后来连本机的也放弃了，再过一段时间重装系统没有备份好数据所有的东西都不见了。写博客总结的事情又被我抛到……</p>
<h2 id="遗忘的想法又重生">遗忘的想法又重生</h2>
<p>这个想法的诞生是我在工作中我领导要给大家分享一个东西，其实我当时对那个东西并不是特别熟。我平时用的也不多，用到的时候忘记了再去查。就这样一次意外我开始觉得我学习的东西被别人认可了，觉得分享自己学习的东西很快乐也能够得到他提供给我的意见或建议。然后我又开始想写博客了，把我学习的东西都总结出来放在博客上。下次用到时看自己曾经写过的东西，一下子法力就恢复了。</p>
<h2 id="再出发">再出发</h2>
<p>我又开始找用哪个工具搭建自己的博客比较好，最后我选择了Gidea这个工具。这也是我一个朋友推荐的，在编程技术上他用的东西我觉得都ok。我自己也对比了其他的工具还是觉得这个比较好，这次搭建的过程也比较顺利。比较顺利的原因不可否认的是我的技术比之前好了，一切顺利。</p>
<h2 id="最后">最后</h2>
<p>一个想法的诞生到执行这个过程时间越长，错过的东西会越多。一个想法只诞生没有执行力，那你终将会失去追求实现这个想法的快乐。2020年的其中一个小目标，坚持写博客提升自我。只争朝夕，不负邵华。</p>
]]></content>
    </entry>
</feed>